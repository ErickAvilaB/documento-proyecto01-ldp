% ---------- Cuerpo del documento ----------

% Titulo
\begin{center}
	% Nombre de la tarea
	\huge
	\tareaName

	% Nombre del autor
	\vspace{0.5cm}
	\large
	Avila Barba Erick Yahir\\
	Galvan Cordoba Uriel Federico\\
	Hernandez Coronel Angel Carlos

	% Fecha
	\vspace{0.3cm}
	\large
	\fecha
\end{center}
\vspace{0.5cm}

\section{Introducción: motivación, objetivos y delimitación del proyecto}

\subsection*{Motivación}
Este proyecto nace para tender un puente claro entre la teoría de lenguajes de
programación y su implementación real. A partir de un lenguaje pequeño tipo
\emph{MiniLisp}, buscamos mostrar cómo las piezas formales (léxico, gramática,
sintaxis abstracta y reglas de evaluación) se traducen en un sistema
ejecutable. El objetivo es que el lector pueda recorrer el ciclo completo: del
papel al programa que corre, entendiendo qué se gana (y qué se pierde) en cada
decisión de diseño.

\subsection*{Objetivos}
\begin{itemize}
	\item \textbf{Formalizar} el lenguaje de superficie y su \emph{core}: léxico, EBNF, Árbol de Sintaxis Abstracta (ASA) y reglas de desazúcar bien especificadas.
	\item \textbf{Definir} la semántica operacional (paso pequeño) para las construcciones del núcleo, con nombres de reglas consistentes y ejemplos de derivación.
	\item \textbf{Implementar} un prototipo funcional en Haskell.
	\item \textbf{Cubrir} las extensiones indicadas en el enunciado (operadores y predicados variádicos, nuevos aritméticos, pares, listas, \texttt{let}/\texttt{let*}/\texttt{letrec}, \texttt{if}/\texttt{if0}, \texttt{cond}, lambdas y aplicación a múltiples argumentos), dejando claro qué es superficie y qué es núcleo.
	\item \textbf{Acompañar} la implementación con casos de prueba y pequeños programas ejemplo (p.\,ej., suma de los primeros $n$, factorial, Fibonacci, \texttt{map}/\texttt{filter}).
\end{itemize}

\subsection*{Delimitación}
Para mantener el alcance razonable y alineado con los objetivos docentes, este
proyecto:
\begin{itemize}
	\item Se enfoca en \textbf{un solo paradigma} (funcional, estilo Lisp) con
	      \textbf{semántica por sustitución/ambientes} y sin efectos laterales complejos.
	\item Incluye \textbf{enteros}, \textbf{booleanos}, \textbf{funciones de primera
		      clase}, \textbf{pares} y \textbf{listas}; \textbf{no} aborda estructuras
	      avanzadas (registros, objetos) ni módulos.
	\item Trabaja con \textbf{evaluación determinista} y especifica \textbf{puntos
		      estrictos} cuando aplique; quedan fuera temas como \textbf{concurrencia},
	      \textbf{paralelismo} y \textbf{laziness global} del runtime.
	\item Define \textbf{errores léxicos/sintácticos} y \textbf{dinámicos básicos}
	      (p.\,ej., tipos incompatibles, aplicación de no-función), pero \textbf{no}
	      implementa un sistema de tipos estático avanzado.
	\item Usa \textbf{Alex} y \textbf{Happy} como herramientas de \textbf{Haskell}.
	\item Prioriza \textbf{claridad}: toda característica de superficie tiene una
	      traducción explícita al núcleo y reglas de evaluación correspondientes.
\end{itemize}

% --- Símbolos para la gramática (categorías y no terminales)
\newcommand{\Id}{\mathit{Id}}
\newcommand{\Int}{\mathit{Int}}
\newcommand{\Bool}{\mathit{Bool}}
\newcommand{\Expr}{\mathit{Expr}}

\section{Gramática base y extensiones solicitadas}

\subsection*{Gramática base}
La siguiente gramática define el lenguaje \emph{MiniLisp} de
\textbf{superficie} antes del desazúcar. Se muestran las categorías léxicas
mínimas y la sintaxis concreta de las construcciones base.

\paragraph{Categorías léxicas.}
\[
	\begin{array}{rcl}
		\Id   & ::= & \text{identificador}                                                      \\
		\Int  & ::= & \text{entero decimal (sin ceros a la izquierda, opcionalmente con signo)} \\
		\Bool & ::= & \#t \mid \#f
	\end{array}
\]

\paragraph{Expresiones.}
\[
	\begin{array}{rcl}
		\Expr & ::=  & \Id \mid \Int \mid \Bool                 \\
		      & \mid & (+\ \Expr\ \Expr) \mid (-\ \Expr\ \Expr) \\
		      & \mid & (not\ \Expr)                             \\
		      & \mid & (let\ (\Id\ \Expr)\ \Expr)               \\
		      & \mid & (letrec\ (\Id\ \Expr)\ \Expr)            \\
		      & \mid & (if0\ \Expr\ \Expr\ \Expr)               \\
		      & \mid & (lambda\ (\Id)\ \Expr)                   \\
		      & \mid & (\Expr\ \Expr) \quad \text{(aplicación)}
	\end{array}
\]

\paragraph{Convenciones.}
\begin{itemize}
	\item La aplicación $(\Expr\ \Expr)$ asocia a la \emph{izquierda}: $(((e_1\ e_2)\
		      e_3)\ \dots)$.
	\item Esta gramática es de \textbf{superficie}; en el \emph{núcleo} se empleará un
	      conjunto mínimo de constructores y desazúcar sistemático.
\end{itemize}

\subsection*{Extensiones solicitadas}
Además de la gramática base, el proyecto requiere incorporar y especificar
formalmente las siguientes funcionalidades. Cada una deberá precisarse léxica y
sintácticamente (EBNF), desazucar a núcleo cuando aplique y contar con reglas
SOS (paso pequeño):

\begin{enumerate}
	\item \textbf{Operadores variádicos} (mínimo 2 argumentos) para aritmética y predicados; documentar orden de evaluación y regla de reducción (plegado).
	\item \textbf{Aritméticos nuevos}: \texttt{*}, \texttt{/} (variádicos), \texttt{add1}, \texttt{sub1}, \texttt{sqrt}, \texttt{expt}.
	\item \textbf{Predicados numéricos} variádicos: \texttt{=}, \texttt{<}, \texttt{>}, \texttt{>=}, \texttt{<=}, \texttt{!=}; aclarar si operan en \emph{cadena} ($x_1 \odot x_2 \odot \dots \odot x_n$) o por pares.
	\item \textbf{Pares y proyecciones}: constructor de pareja $(e_1, e_2)$ y selectores \texttt{fst}, \texttt{snd}.
	\item \textbf{\texttt{let} y \texttt{let*} variádicos}: múltiples asignaciones; \texttt{let} paralelo (sin dependencias cruzadas) y \texttt{let*} secuencial (permite dependencias).
	\item \textbf{Condicional booleano} \texttt{(if e1 e2 e3)} y su relación con \texttt{if0} (decidir primitiva o azúcar).
	\item \textbf{Listas con corchetes} y operaciones: literales \texttt{[e, ...]}, \texttt{head}, \texttt{tail}, y lista vacía \texttt{[]}; definir si son homogéneas y su traducción (p.\,ej., a \texttt{nil}/\texttt{cons} o a pares anidados).
	\item \textbf{\texttt{cond} con \texttt{else}}: cláusulas ordenadas \texttt{[guard expr]} \dots \texttt{[else expr]} con reglas claras para el último caso.
	\item \textbf{Lambdas variádicas} y \textbf{aplicación con múltiples argumentos}: \texttt{(lambda (x y z) e)} y \texttt{(f a b c)}; precisar semántica y desazúcar (p.\,ej., currificación) hacia el núcleo unario.
\end{enumerate}


\section{Sintaxis léxica}

\subsection{Alfabeto (\texorpdfstring{$\Sigma$}{Sigma})}

Se restringe el alfabeto del lenguaje al siguiente subconjunto de ASCII:

\begin{itemize}
	\item \textbf{Letras}: \texttt{A..Z}, \texttt{a..z}
	\item \textbf{Dígitos}: \texttt{0..9}
	\item \textbf{Espacios en blanco}: espacio ' ', tabulación horizontal (\verb|\t|), salto de línea (\verb|\n|).
	\item \textbf{Símbolos utilizados por el lenguaje}: \texttt{( ) [ ] , ; \# | + - * / = < > \_}
\end{itemize}

Cualquier carácter fuera de esta lista debe producir \textbf{error léxico}.

\subsection{Espacios en blanco y comentarios}

\begin{itemize}
	\item \textbf{Espacios en blanco}: separan tokens y se ignoran fuera de literales (no hay literales de cadena en esta versión del lenguaje).
	\item \textbf{Comentario de línea}: desde \texttt{;} hasta fin de línea.
	\item \textbf{Comentario de bloque (no anidable)}: \texttt{\#|} \dots \texttt{|\#}. Si se abre y no se cierra, es error.
\end{itemize}

\begin{code}
	LINE_COMMENT   ::= ';' [^\n]*
	BLOCK_COMMENT  ::= '#|' (.| \n)*? '|#'       // no anidable
	WS              ::= [ \t\r\n]+               // ignorar
\end{code}

\subsection{Clases de tokens y expresiones regulares}

A continuación se definen las principales clases de tokens mediante expresiones
regulares.

\subsubsection{Booleanos}
\begin{code}
	BOOL ::= '#t' | '#f'
\end{code}

\subsubsection{Enteros con signo}
\begin{code}
	INT ::= [+\-]?[0-9]+
\end{code}
\textit{Nota:} el signo unario forma parte del literal sólo cuando precede inmediatamente a dígitos; un \texttt{-} aislado se tokeniza como operador.

\subsubsection{Identificadores}
\begin{code}
	ID ::= [A-Za-z][A-Za-z0-9_]*
\end{code}
Se permiten sufijos numéricos (p.\,ej., \texttt{add1}). No se permite \texttt{-} interno para evitar ambigüedad con el operador \texttt{-}.

\subsubsection{Palabras reservadas}
Se reconocen como tokens propios (no como \texttt{ID}). Implementación típica:
tras escanear un \texttt{ID}, consultar una tabla de palabras clave.

\begin{center}
	\begin{tabular}{>{\ttfamily}l l}
		\toprule
		add1       & operación aritmética (incremento)            \\
		sub1       & operación aritmética (decremento)            \\
		sqrt       & raíz cuadrada                                \\
		expt       & potencia                                     \\
		head, tail & operaciones sobre listas                     \\
		fst, snd   & proyecciones de pares                        \\
		let, let*  & asignaciones locales (paralelo / secuencial) \\
		if         & condicional booleano                         \\
		cond, else & condicional por clausulado                   \\
		lambda     & función anónima                              \\
		\bottomrule
	\end{tabular}
\end{center}

\noindent
\begin{code}
	RESERVED ::=
	'add1' | 'sub1' | 'sqrt' | 'expt' |
	'head' | 'tail' | 'fst'  | 'snd'  |
	'let*' | 'let'  | 'if'   | 'cond' | 'else' | 'lambda'
\end{code}

\subsubsection{Operadores}
\begin{itemize}
	\item \textbf{Aritméticos}: \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}
	\item \textbf{Comparación}: \texttt{=}, \texttt{<}, \texttt{>}, \texttt{<=}, \texttt{>=}, \texttt{!=}
\end{itemize}

\noindent
\begin{code}
	OP2 ::= '<=' | '>=' | '!='
	OP1 ::= [+\-*/=<>]
\end{code}

\subsubsection{Delimitadores y separadores}
\begin{itemize}
	\item \textbf{Paréntesis}: \texttt{(} \; \texttt{)}
	\item \textbf{Corchetes}: \texttt{[} \; \texttt{]}
	\item \textbf{Coma}: \texttt{,}
\end{itemize}

\noindent
\begin{code}
	LPAREN  ::= '('
	RPAREN  ::= ')'
	LBRACK  ::= '['
	RBRACK  ::= ']'
	COMMA   ::= ','
\end{code}

\subsection{Lista canónica de reglas de escaneo (orden de aplicación)}

\begin{code}
	// 1) Ignorar blancos y comentarios
	WS              ::= [ \t\r\n]+                     => skip
	LINE_COMMENT    ::= ';' [^\n]*                     => skip
	BLOCK_COMMENT   ::= '#|' (.| \n)*? '|#'            => skip

	// 2) Operadores multicarácter
	OP2             ::= '<=' | '>=' | '!='

	// 3) Palabras reservadas específicas antes que ID (ej. let*)
	RESERVED        ::= 'add1'|'sub1'|'sqrt'|'expt'|'head'|'tail'|
	'fst'|'snd'|'let*'|'let'|'if'|'cond'|'else'|'lambda'

	// 4) Booleanos y literales
	BOOL            ::= '#t' | '#f'
	INT             ::= [+\-]?[0-9]+

	// 5) Identificadores
	ID              ::= [A-Za-z][A-Za-z0-9_]*           // aceptar sólo si no es RESERVED

	// 6) Operadores de un carácter y delimitadores
	OP1             ::= [+\-*/=<>]
	LPAREN          ::= '('
	RPAREN          ::= ')'
	LBRACK          ::= '['
	RBRACK          ::= ']'
	COMMA           ::= ','
\end{code}

\subsection{Ejemplos de tokenización}

\paragraph{Operadores variádicos.}
\begin{code}
	(+ 1 2 3 4)
	// TOKENS: LPAREN, OP1(+), INT(1), INT(2), INT(3), INT(4), RPAREN
\end{code}

\paragraph{Comparaciones multicarácter.}
\begin{code}
	(<= 2 5 5)
	// TOKENS: LPAREN, OP2(<=), INT(2), INT(5), INT(5), RPAREN
\end{code}

\paragraph{Asignaciones locales y palabras reservadas.}
\begin{code}
	(let* ((x 3) (y (+ x 1))) (+ x y))
	// TOKENS: RESERVED(let*), LPAREN, LPAREN, ID(x), INT(3), RPAREN, ...
\end{code}

\paragraph{Listas con corchetes y coma.}
\begin{code}
	(head [1, 2, 3, 4])
	// TOKENS: RESERVED(head), LBRACK, INT(1), COMMA, INT(2), COMMA, INT(3), COMMA, INT(4), RBRACK
\end{code}

\paragraph{Comentarios.}
\begin{code}
	; esto es un comentario de línea
	#| comentario
	de bloque |# (+ 1 2)
\end{code}

% ------------------------------------------------------------
% Sección: Sintaxis Libre de Contexto (EBNF) de MiniLisp
% ------------------------------------------------------------
\section{Sintaxis libre de contexto (EBNF) del lenguaje extendido}

Esta sección especifica la gramática del lenguaje en EBNF, coherente con el
léxico del proyecto: paréntesis \texttt{( )}, corchetes \texttt{[ ]}, coma
\texttt{,}, booleanos \texttt{\#t}/\texttt{\#f}, identificadores, enteros con
signo, operadores aritméticos y de comparación, y las palabras clave indicadas.
Toda la notación de la gramática se presenta en ASCII.

\subsection*{Convenciones de EBNF}
Terminales entre comillas simples (p.~ej., \texttt{'('}), no terminales entre
\texttt{<>}, repetición \texttt{\{ \}}, opción \texttt{[ ]}. Las producciones
se han unificado en \texttt{<Expr>} para que cada construcción aparezca
explícitamente donde corresponde.

\subsection*{Gramática (EBNF) sin comillas en terminales}

\begin{lstlisting}[basicstyle=\ttfamily\small,columns=fullflexible,keepspaces=true,showstringspaces=false,frame=single,xleftmargin=1em,upquote=true]
(* ===== Program ===== *)
<Program> ::= <Expr>

(* ===== Expressions (all here) ===== *)
<Expr> ::=
    <ID>
  | <INT>
  | <BOOL>

  (* pairs and projections *)
  | ( <Expr> , <Expr> )
  | ( fst <Expr> )
  | ( snd <Expr> )

  (* lists and operations *)
  | [ ]
  | [ <Expr> { , <Expr> } ]
  | ( head <Expr> )
  | ( tail <Expr> )

  (* conditionals *)
  | ( if <Expr> <Expr> <Expr> )
  | ( cond { [ <Expr> <Expr> ] } [ else <Expr> ] )

  (* local bindings *)
  | ( let  ( <Binding> { <Binding> } ) <Expr> )
  | ( let* ( <Binding> { <Binding> } ) <Expr> )

  (* lambda and application *)
  | ( lambda ( <ID> { <ID> } ) <Expr> )
  | ( <Expr> <Expr> { <Expr> } )            (* application: >= 1 arg *)

  (* unary primitives and binary expt *)
  | ( add1 <Expr> )
  | ( sub1 <Expr> )
  | ( sqrt <Expr> )
  | ( expt <Expr> <Expr> )

  (* arithmetic variadic: >= 2 args *)
  | ( + <Expr> <Expr> { <Expr> } )
  | ( - <Expr> <Expr> { <Expr> } )
  | ( * <Expr> <Expr> { <Expr> } )
  | ( / <Expr> <Expr> { <Expr> } )

  (* comparisons variadic: >= 2 args *)
  | ( =  <Expr> <Expr> { <Expr> } )
  | ( <  <Expr> <Expr> { <Expr> } )
  | ( >  <Expr> <Expr> { <Expr> } )
  | ( <= <Expr> <Expr> { <Expr> } )
  | ( >= <Expr> <Expr> { <Expr> } )
  | ( != <Expr> <Expr> { <Expr> } )

(* ===== Aux ===== *)
<Binding> ::= ( <ID> <Expr> )

(* ===== Lexical reference (ASCII) ===== *)
<ID>   ::= letter ( letter | digit | '_' )*
<INT>  ::= ['+'|'-']? digit+
<BOOL> ::= #t | #f
\end{lstlisting}

\subsection*{Restricciones estáticas (aridad y forma)}
\begin{itemize}
	\item Operadores variádicos \texttt{+ - * / = < > <= >= !=}: requieren al menos 2
	      argumentos.
	\item Aplicación de funciones: requiere al menos 1 argumento (\texttt{(f a [b]
		      ...)}).
	\item \texttt{lambda}: al menos 1 parámetro.
	\item \texttt{let} y \texttt{let*}: al menos 1 ligadura.
	\item \texttt{cond}: debe incluir una cláusula final \texttt{[else e]}; si aparece \texttt{else}, es la última.
\end{itemize}

\subsection*{Convenciones semánticas}
\begin{itemize}
	\item Evaluación estricta de izquierda a derecha.
	\item Operadores variádicos aritméticos (\texttt{+ - * /}): plegado izquierdo;
	      p.~ej., \texttt{(+ a b c d)} = \texttt{(((a+b)+c)+d)}. Para \texttt{/}, la
	      división es binaria iterada.
	\item Comparaciones variádicas (\texttt{< > <= >= = !=}): interpretación en cadena;
	      p.~ej., \texttt{(< a b c)} equivale a \texttt{(a<b) \&\& (b<c)}.
	\item \texttt{expt} se define binaria: \texttt{(expt base exp)}.
	\item \texttt{let}: ligaduras evaluadas en el ambiente original (paralelo). \texttt{let*}: evaluación secuencial, extendiendo el ambiente en cada paso.
	\item Listas con corchetes son azúcar sintáctica hacia un núcleo con
	      \texttt{nil/cons} o pares encadenados; por ejemplo, \texttt{[e1, e2, e3]}
	      $\Rightarrow$ \texttt{(cons e1 (cons e2 (cons e3 nil)))}.
\end{itemize}
=======
\paragraph{Nota de diseño.}
Cada extensión debe venir acompañada de: (i) reglas de desazúcar sobre el
\textbf{ASA}, (ii) reglas SOS con nombres consistentes, y (iii) ejemplos de
derivación y pruebas unitarias que cubran casos normales y de error.

\section{Sintaxis abstracta (ASA)}

\subsection{Justificación y principios de diseño}

La \emph{Sintaxis Abstracta} (ASA) es la forma estructural del programa: organiza las expresiones por sus subexpresiones y deja fuera detalles de la escritura (paréntesis, comas, corchetes). Cada constructor se forma a partir de las ASAs de sus componentes y, cuando la EBNF usa repetición {…}, en la ASA eso se refleja como una lista (argumentos de operadores y comparadores, parámetros de \texttt{lambda}, argumentos de aplicación, ligaduras de \texttt{let}/\texttt{let*}, cláusulas de \texttt{cond}, elementos de listas). Se respetan las aridades mínimas de la gramática (por ejemplo, operadores y comparadores con  n\(=>\)2, \texttt{lambda} con al menos un parámetro, aplicación con al menos un argumento, \texttt{let}/\texttt{let*} con al menos una ligadura) y las ligaduras quedan explícitas: los parámetros de \texttt{lambda} y las variables de \texttt{let}/\texttt{let*} ligan en el cuerpo. La ASA no fija el modo de evaluación; esas decisiones se precisan después en la semántica y, cuando corresponda, en el tratamiento del azúcar y su desazucarización.

\subsection{Reglas de formación}

% (Opcional pero útil en el preámbulo)
% \providecommand{\ASA}{\mathit{ASA}} % Si prefieres \ASA en vez de \mathrm{ASA}

\paragraph{Átomos.}
\[
\frac{n\in\mathbb{Z}}{\mathrm{Num}(n)\ \in\ \mathrm{ASA}}
\qquad
\frac{b\in\{\#t,\#f\}}{\mathrm{Bool}(b)\ \in\ \mathrm{ASA}}
\qquad
\frac{x\in \mathrm{Id}}{\mathrm{Var}(x)\ \in\ \mathrm{ASA}}
\]

\paragraph{Aritméticos variádicos \texorpdfstring{$(+\ -\ *\ /)$} con $n\ge 2$.}
\[
\frac{a_1\in\mathrm{ASA}\ \ \cdots\ \ a_n\in\mathrm{ASA}\ \ \ n\ge 2}
     {\mathrm{Add}_{\texttt{}}\big([a_1,\dots,a_n]\big)\ \in\ \mathrm{ASA}}
\qquad
\frac{a_1\in\mathrm{ASA}\ \ \cdots\ \ a_n\in\mathrm{ASA}\ \ \ n\ge 2}
     {\mathrm{Sub}_{\texttt{}}\big([a_1,\dots,a_n]\big)\ \in\ \mathrm{ASA}}
\]
\[
\frac{a_1\in\mathrm{ASA}\ \ \cdots\ \ a_n\in\mathrm{ASA}\ \ \ n\ge 2}
     {\mathrm{Mul}{\texttt{}}\big([a_1,\dots,a_n]\big)\ \in\ \mathrm{ASA}}
\qquad
\frac{a_1\in\mathrm{ASA}\ \ \cdots\ \ a_n\in\mathrm{ASA}\ \ \ n\ge 2}
     {\mathrm{Div}_{\texttt{}}\big([a_1,\dots,a_n]\big)\ \in\ \mathrm{ASA}}
\]

\paragraph{Unarios y potencia.}
\[
\frac{e\in\mathrm{ASA}}{\mathrm{Add1}(e)\ \in\ \mathrm{ASA}}
\qquad
\frac{e\in\mathrm{ASA}}{\mathrm{Sub1}(e)\ \in\ \mathrm{ASA}}
\qquad
\frac{e\in\mathrm{ASA}}{\mathrm{Sqrt}(e)\ \in\ \mathrm{ASA}}
\qquad
\frac{\mathrm{base}\in\mathrm{ASA}\ \ \ \mathrm{exp}\in\mathrm{ASA}}
     {\mathrm{Expt}(\mathrm{base},\mathrm{exp})\ \in\ \mathrm{ASA}}
\]

\paragraph{Predicados variádicos \texorpdfstring{$(=\ <\ >\ \le\ \ge\ $}{!=)} con $n\ge 2$.}

\[
\frac{a_1\in\mathrm{ASA}\ \ \cdots\ \ a_n\in\mathrm{ASA}\ \ \ n\ge 2}
     {\mathrm{Igual}\big([a_1,\dots,a_n]\big)\ \in\ \mathrm{ASA}}
\qquad
\frac{a_1\in\mathrm{ASA}\ \ \cdots\ \ a_n\in\mathrm{ASA}\ \ \ n\ge 2}
     {\mathrm{Menorq}\big([a_1,\dots,a_n]\big)\ \in\ \mathrm{ASA}}
\]
\[
\frac{a_1\in\mathrm{ASA}\ \ \cdots\ \ a_n\in\mathrm{ASA}\ \ \ n\ge 2}
     {\mathrm{Mayorq}\big([a_1,\dots,a_n]\big)\ \in\ \mathrm{ASA}}
\qquad
\frac{a_1\in\mathrm{ASA}\ \ \cdots\ \ a_n\in\mathrm{ASA}\ \ \ n\ge 2}
     {\mathrm{MenorIgu}\big([a_1,\dots,a_n]\big)\ \in\ \mathrm{ASA}}
\]
\[
\frac{a_1\in\mathrm{ASA}\ \ \cdots\ \ a_n\in\mathrm{ASA}\ \ \ n\ge 2}
     {\mathrm{MayorIgu}\big([a_1,\dots,a_n]\big)\ \in\ \mathrm{ASA}}
\qquad
\frac{a_1\in\mathrm{ASA}\ \ \cdots\ \ a_n\in\mathrm{ASA}\ \ \ n\ge 2}
     {\mathrm{NoIgual}\big([a_1,\dots,a_n]\big)\ \in\ \mathrm{ASA}}
\]

\paragraph{Pares y proyecciones.}
\[
\frac{e_1\in\mathrm{ASA}\ \ \ e_2\in\mathrm{ASA}}
     {\mathrm{Par}(e_1,e_2)\ \in\ \mathrm{ASA}}
\qquad
\frac{e\in\mathrm{ASA}}{\mathrm{Fst}(e)\ \in\ \mathrm{ASA}}
\qquad
\frac{e\in\mathrm{ASA}}{\mathrm{Snd}(e)\ \in\ \mathrm{ASA}}
\]

\paragraph{Listas y operaciones.}
\[
\frac{e_1\in\mathrm{ASA}\ \ \cdots\ \ e_n\in\mathrm{ASA}\ \ \ n\ge 0}
     {\mathrm{Lista}([e_1,\dots,e_n])\ \in\ \mathrm{ASA}}
\qquad
\frac{e\in\mathrm{ASA}}{\mathrm{Head}(e)\ \in\ \mathrm{ASA}}
\qquad
\frac{e\in\mathrm{ASA}}{\mathrm{Tail}(e)\ \in\ \mathrm{ASA}}
\]

\paragraph{Condicionales.}
\[
\frac{t\in\mathrm{ASA}\ \ \ \mathrm{th}\in\mathrm{ASA}\ \ \ \mathrm{el}\in\mathrm{ASA}}
     {\mathrm{If}(t,\mathrm{th},\mathrm{el})\ \in\ \mathrm{ASA}}
\]
\[
\frac{g_1\in\mathrm{ASA}\ \ e_1\in\mathrm{ASA}\ \ \cdots\ \ g_r\in\mathrm{ASA}\ \ e_r\in\mathrm{ASA}\ \ \ \mathrm{el}\in\mathrm{ASA}\ \ \ r\ge 1}
     {\mathrm{Cond}\big([(g_1,e_1),\dots,(g_r,e_r)],\ \mathrm{el}\big)\ \in\ \mathrm{ASA}}
\]

\paragraph{Asignaciones locales.}
\[
\frac{x_1\in \mathrm{Id},\ e_1\in\mathrm{ASA}\ \ \cdots\ \ x_k\in \mathrm{Id},\ e_k\in\mathrm{ASA}\ \ \ \mathrm{body}\in\mathrm{ASA}\ \ \ k\ge 1}
     {\mathrm{Let}\big([(x_1,e_1),\dots,(x_k,e_k)],\ \mathrm{body}\big)\ \in\ \mathrm{ASA}}
\]
\[
\frac{x_1\in \mathrm{Id},\ e_1\in\mathrm{ASA}\ \ \cdots\ \ x_k\in \mathrm{Id},\ e_k\in\mathrm{ASA}\ \ \ \mathrm{body}\in\mathrm{ASA}\ \ \ k\ge 1}
     {\mathrm{\texttt{let*}}\big([(x_1,e_1),\dots,(x_k,e_k)],\ \mathrm{body}\big)\ \in\ \mathrm{ASA}}
\]

\paragraph{Funciones anónimas y aplicación.}
\[
\frac{x_1\in \mathrm{Id}\ \ \cdots\ \ x_n\in \mathrm{Id}\ \ \ \mathrm{c}\in\mathrm{ASA}\ \ \ n\ge 1}
     {\mathrm{Lambda}\big([x_1,\dots,x_n],\ \mathrm{c}\big)\ \in\ \mathrm{ASA}}
\qquad
\frac{f\in\mathrm{ASA}\ \ a_1\in\mathrm{ASA}\ \ \cdots\ \ a_m\in\mathrm{ASA}\ \ \ m\ge 1}
     {\mathrm{App}(f,\ [a_1,\dots,a_m])\ \in\ \mathrm{ASA}}
\]

