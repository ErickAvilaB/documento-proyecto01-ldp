% ---------- Cuerpo del documento ----------

% Titulo
\begin{center}
	% Nombre de la tarea
	\huge
	\tareaName

	% Nombre del autor
	\vspace{0.5cm}
	\large
	Avila Barba Erick Yahir\\
	Galvan Cordoba Uriel Federico\\
	Hernandez Coronel Angel Carlos

	% Fecha
	\vspace{0.3cm}
	\large
	\fecha
\end{center}
\vspace{0.5cm}

\section{Introducción: motivación, objetivos y delimitación del proyecto}

\subsection*{Motivación}
Este proyecto nace para tender un puente claro entre la teoría de lenguajes de
programación y su implementación real. A partir de un lenguaje pequeño tipo
\emph{MiniLisp}, buscamos mostrar cómo las piezas formales (léxico, gramática,
sintaxis abstracta y reglas de evaluación) se traducen en un sistema
ejecutable. El objetivo es que el lector pueda recorrer el ciclo completo: del
papel al programa que corre, entendiendo qué se gana (y qué se pierde) en cada
decisión de diseño.

\subsection*{Objetivos}
\begin{itemize}
	\item \textbf{Formalizar} el lenguaje de superficie y su \emph{core}: léxico, EBNF, Árbol de Sintaxis Abstracta (ASA) y reglas de desazúcar bien especificadas.
	\item \textbf{Definir} la semántica operacional (paso pequeño) para las construcciones del núcleo, con nombres de reglas consistentes y ejemplos de derivación.
	\item \textbf{Implementar} un prototipo funcional en Haskell.
	\item \textbf{Cubrir} las extensiones indicadas en el enunciado (operadores y predicados variádicos, nuevos aritméticos, pares, listas, \texttt{let}/\texttt{let*}/\texttt{letrec}, \texttt{if}/\texttt{if0}, \texttt{cond}, lambdas y aplicación a múltiples argumentos), dejando claro qué es superficie y qué es núcleo.
	\item \textbf{Acompañar} la implementación con casos de prueba y pequeños programas ejemplo (p.\,ej., suma de los primeros $n$, factorial, Fibonacci, \texttt{map}/\texttt{filter}).
\end{itemize}

\subsection*{Delimitación}
Para mantener el alcance razonable y alineado con los objetivos docentes, este
proyecto:
\begin{itemize}
	\item Se enfoca en \textbf{un solo paradigma} (funcional, estilo Lisp) con
	      \textbf{semántica por sustitución/ambientes} y sin efectos laterales complejos.
	\item Incluye \textbf{enteros}, \textbf{booleanos}, \textbf{funciones de primera
		      clase}, \textbf{pares} y \textbf{listas}; \textbf{no} aborda estructuras
	      avanzadas (registros, objetos) ni módulos.
	\item Trabaja con \textbf{evaluación determinista} y especifica \textbf{puntos
		      estrictos} cuando aplique; quedan fuera temas como \textbf{concurrencia},
	      \textbf{paralelismo} y \textbf{laziness global} del runtime.
	\item Define \textbf{errores léxicos/sintácticos} y \textbf{dinámicos básicos}
	      (p.\,ej., tipos incompatibles, aplicación de no-función), pero \textbf{no}
	      implementa un sistema de tipos estático avanzado.
	\item Usa \textbf{Alex} y \textbf{Happy} como herramientas de \textbf{Haskell}.
	\item Prioriza \textbf{claridad}: toda característica de superficie tiene una
	      traducción explícita al núcleo y reglas de evaluación correspondientes.
\end{itemize}

% --- Símbolos para la gramática (categorías y no terminales)
\newcommand{\Id}{\mathit{Id}}
\newcommand{\Int}{\mathit{Int}}
\newcommand{\Bool}{\mathit{Bool}}
\newcommand{\Expr}{\mathit{Expr}}

\section{Gramática base y extensiones solicitadas}

\subsection*{Gramática base}
La siguiente gramática define el lenguaje \emph{MiniLisp} de
\textbf{superficie} antes del desazúcar. Se muestran las categorías léxicas
mínimas y la sintaxis concreta de las construcciones base.

\paragraph{Categorías léxicas.}
\[
	\begin{array}{rcl}
		\Id   & ::= & \text{identificador}                                                      \\
		\Int  & ::= & \text{entero decimal (sin ceros a la izquierda, opcionalmente con signo)} \\
		\Bool & ::= & \#t \mid \#f
	\end{array}
\]

\paragraph{Expresiones.}
\[
	\begin{array}{rcl}
		\Expr & ::=  & \Id \mid \Int \mid \Bool                 \\
		      & \mid & (+\ \Expr\ \Expr) \mid (-\ \Expr\ \Expr) \\
		      & \mid & (not\ \Expr)                             \\
		      & \mid & (let\ (\Id\ \Expr)\ \Expr)               \\
		      & \mid & (letrec\ (\Id\ \Expr)\ \Expr)            \\
		      & \mid & (if0\ \Expr\ \Expr\ \Expr)               \\
		      & \mid & (lambda\ (\Id)\ \Expr)                   \\
		      & \mid & (\Expr\ \Expr) \quad \text{(aplicación)}
	\end{array}
\]

\paragraph{Convenciones.}
\begin{itemize}
	\item La aplicación $(\Expr\ \Expr)$ asocia a la \emph{izquierda}: $(((e_1\ e_2)\
		      e_3)\ \dots)$.
	\item Esta gramática es de \textbf{superficie}; en el \emph{núcleo} se empleará un
	      conjunto mínimo de constructores y desazúcar sistemático.
\end{itemize}

\subsection*{Extensiones solicitadas}
Además de la gramática base, el proyecto requiere incorporar y especificar
formalmente las siguientes funcionalidades. Cada una deberá precisarse léxica y
sintácticamente (EBNF), desazucar a núcleo cuando aplique y contar con reglas
SOS (paso pequeño):

\begin{enumerate}
	\item \textbf{Operadores variádicos} (mínimo 2 argumentos) para aritmética y predicados; documentar orden de evaluación y regla de reducción (plegado).
	\item \textbf{Aritméticos nuevos}: \texttt{*}, \texttt{/} (variádicos), \texttt{add1}, \texttt{sub1}, \texttt{sqrt}, \texttt{expt}.
	\item \textbf{Predicados numéricos} variádicos: \texttt{=}, \texttt{<}, \texttt{>}, \texttt{>=}, \texttt{<=}, \texttt{!=}; aclarar si operan en \emph{cadena} ($x_1 \odot x_2 \odot \dots \odot x_n$) o por pares.
	\item \textbf{Pares y proyecciones}: constructor de pareja $(e_1, e_2)$ y selectores \texttt{fst}, \texttt{snd}.
	\item \textbf{\texttt{let} y \texttt{let*} variádicos}: múltiples asignaciones; \texttt{let} paralelo (sin dependencias cruzadas) y \texttt{let*} secuencial (permite dependencias).
	\item \textbf{Condicional booleano} \texttt{(if e1 e2 e3)} y su relación con \texttt{if0} (decidir primitiva o azúcar).
	\item \textbf{Listas con corchetes} y operaciones: literales \texttt{[e, ...]}, \texttt{head}, \texttt{tail}, y lista vacía \texttt{[]}; definir si son homogéneas y su traducción (p.\,ej., a \texttt{nil}/\texttt{cons} o a pares anidados).
	\item \textbf{\texttt{cond} con \texttt{else}}: cláusulas ordenadas \texttt{[guard expr]} \dots \texttt{[else expr]} con reglas claras para el último caso.
	\item \textbf{Lambdas variádicas} y \textbf{aplicación con múltiples argumentos}: \texttt{(lambda (x y z) e)} y \texttt{(f a b c)}; precisar semántica y desazúcar (p.\,ej., currificación) hacia el núcleo unario.
\end{enumerate}

\section{Sintaxis léxica}

\subsection{Alfabeto (\texorpdfstring{$\Sigma$}{Sigma})}

Se restringe el alfabeto del lenguaje al siguiente subconjunto de ASCII:

\begin{itemize}
	\item \textbf{Letras}: \texttt{A..Z}, \texttt{a..z}
	\item \textbf{Dígitos}: \texttt{0..9}
	\item \textbf{Espacios en blanco}: espacio ' ', tabulación horizontal (\verb|\t|), salto de línea (\verb|\n|).
	\item \textbf{Símbolos utilizados por el lenguaje}: \texttt{( ) [ ] , ; \# | + - * / = < > \_}
\end{itemize}

Cualquier carácter fuera de esta lista debe producir \textbf{error léxico}.

\subsection{Espacios en blanco y comentarios}

\begin{itemize}[leftmargin=*]

	\item \textbf{LINE\_COMMENT ::=} \verb|; [^\n]*| \\
	      Comentario de línea: inicia con \verb|;| y consume cero o más caracteres que no sean salto de línea hasta el fin de la línea.

	\item \textbf{BLOCK\_COMMENT ::=} \verb+#| (.| \n)*? |#+ \\
	      Comentario de bloque (no anidable): inicia con \verb+#|+ y abarca cualquier carácter (incluido \verb|\n|) de forma no codiciosa hasta \verb+|#+.

	\item \textbf{WS ::=} \verb|[ \t\r\n]+| \\
	      Espacios en blanco: uno o más espacios, tabulaciones (\verb|\t|), retornos de carro (\verb|\r|) o saltos de línea (\verb|\n|); típicamente se ignoran.

\end{itemize}

\subsection{Clases de tokens y expresiones regulares}

A continuación se definen las principales clases de tokens mediante expresiones
regulares.

\subsubsection{Booleanos}
\begin{code}
	BOOL ::= '#t' | '#f'
\end{code}

\subsubsection{Enteros con signo}
\begin{code}
	INT ::= [+\-]?[0-9]+
\end{code}

\begin{itemize}
	\item \verb|[+\-]?| — opcionalmente un solo \verb|+| o \verb|-| al inicio.
	\item \verb|[0-9]+| — una o más cifras decimales consecutivas.
\end{itemize}
\textit{Nota:} el signo unario forma parte del literal sólo cuando precede inmediatamente a dígitos; un \texttt{-} aislado se tokeniza como operador.

\subsubsection{Identificadores}
Los identificadores usados para \texttt{let}, se forman de la siguiente manera:
\begin{code}
	ID ::= [A-Za-z][A-Za-z0-9_]*
\end{code}
Se permiten sufijos numéricos (p.\,ej., \texttt{var1}). No se permite \texttt{-} interno para evitar ambigüedad con el operador \texttt{-}.

\subsubsection{Palabras reservadas}
Se reconocen como tokens propios (no como \texttt{ID}). Implementación típica:
tras escanear un \texttt{ID}, consultar una tabla de palabras clave.

\begin{center}
	\begin{tabular}{>{\ttfamily}l l}
		\toprule
		add1       & operación aritmética (incremento)            \\
		sub1       & operación aritmética (decremento)            \\
		sqrt       & raíz cuadrada                                \\
		expt       & potencia                                     \\
		head, tail & operaciones sobre listas                     \\
		fst, snd   & proyecciones de pares                        \\
		let, let*  & asignaciones locales (paralelo / secuencial) \\
		if         & condicional booleano                         \\
		cond, else & condicional por clausulado                   \\
		lambda     & función anónima                              \\
		\bottomrule
	\end{tabular}
\end{center}

\noindent
\begin{code}
	RESERVED ::=
	'add1' | 'sub1' | 'sqrt' | 'expt' |
	'head' | 'tail' | 'fst'  | 'snd'  |
	'let*' | 'let'  | 'if'   | 'cond' | 'else' | 'lambda'
\end{code}

\subsubsection{Operadores}
\begin{itemize}
	\item \textbf{Aritméticos}: \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}
	\item \textbf{Comparación}: \texttt{=}, \texttt{<}, \texttt{>}, \texttt{<=}, \texttt{>=}, \texttt{!=}
\end{itemize}

\noindent
\begin{code}
	OP2 ::= '<=' | '>=' | '!='
	OP1 ::= [+\-*/=<>]
\end{code}

\subsubsection{Delimitadores y separadores}
\begin{itemize}
	\item \textbf{Paréntesis}: \texttt{(} \; \texttt{)}
	\item \textbf{Corchetes}: \texttt{[} \; \texttt{]}
	\item \textbf{Coma}: \texttt{,}
\end{itemize}

\noindent
\begin{code}
	LPAREN  ::= '('
	RPAREN  ::= ')'
	LBRACK  ::= '['
	RBRACK  ::= ']'
	COMMA   ::= ','
\end{code}

\subsection{Lista completa de reglas léxicas}

\begin{code}
	// Ignorar blancos y comentarios
	WS              ::= [ \t\r\n]+                     => skip
	LINE_COMMENT    ::= ';' [^\n]*                     => skip
	BLOCK_COMMENT   ::= '#|' (.| \n)*? '|#'            => skip

	// Operadores multicarácter
	OP2             ::= '<=' | '>=' | '!='

	// Palabras reservadas específicas antes que ID (ej. let*)
	RESERVED        ::= 'add1'|'sub1'|'sqrt'|'expt'|'head'|'tail'|
	'fst'|'snd'|'let*'|'let'|'if'|'cond'|'else'|'lambda'

	// Booleanos y literales
	BOOL            ::= '#t' | '#f'
	INT             ::= [+\-]?[0-9]+

	// Identificadores
	ID              ::= [A-Za-z][A-Za-z0-9_]*           // aceptar sólo si no es RESERVED

	// Operadores de un carácter y delimitadores
	OP1             ::= [+\-*/=<>]
	LPAREN          ::= '('
	RPAREN          ::= ')'
	LBRACK          ::= '['
	RBRACK          ::= ']'
	COMMA           ::= ','
\end{code}

\subsection{Ejemplos de tokenización}

\paragraph{Operadores variádicos.}
\begin{code}
	(+ 1 2 3 4)
	// TOKENS: LPAREN, OP1(+), INT(1), INT(2), INT(3), INT(4), RPAREN
\end{code}

\paragraph{Comparaciones multicarácter.}
\begin{code}
	(<= 2 5 5)
	// TOKENS: LPAREN, OP2(<=), INT(2), INT(5), INT(5), RPAREN
\end{code}

\paragraph{Asignaciones locales y palabras reservadas.}
\begin{code}
	(let* ((x 3) (y (+ x 1))) (+ x y))
	// TOKENS: RESERVED(let*), LPAREN, LPAREN, ID(x), INT(3), RPAREN, ...
\end{code}

\paragraph{Listas con corchetes y coma.}
\begin{code}
	(head [1, 2, 3, 4])
	// TOKENS: RESERVED(head), LBRACK, INT(1), COMMA, INT(2), COMMA, INT(3), COMMA, INT(4), RBRACK
\end{code}

\paragraph{Comentarios.}
\begin{code}
	; esto es un comentario de línea
	#| comentario
	de bloque |# (+ 1 2)
\end{code}

% ------------------------------------------------------------
% Sección: Sintaxis Libre de Contexto (EBNF) de MiniLisp
% ------------------------------------------------------------
\section{Sintaxis libre de contexto (EBNF) del lenguaje extendido}

Esta sección especifica la gramática del lenguaje en EBNF, coherente con el
léxico del proyecto: paréntesis \texttt{( )}, corchetes \texttt{[ ]}, coma
\texttt{,}, booleanos \texttt{\#t}/\texttt{\#f}, identificadores, enteros con
signo, operadores aritméticos y de comparación, y las palabras clave indicadas.
Toda la notación de la gramática se presenta en ASCII.

\subsection*{Gramática (EBNF)}

\begin{lstlisting}[basicstyle=\ttfamily\small,columns=fullflexible,keepspaces=true,showstringspaces=false,frame=single,xleftmargin=1em,upquote=true]
<Program> ::= <Expr>

<Expr> ::=
    <ID>
  | <INT>
  | <BOOL>

  | ( <Expr> , <Expr> )
  | ( fst <Expr> )
  | ( snd <Expr> )

  | [ ]
  | [ <Expr> { , <Expr> } ]
  | ( head <Expr> )
  | ( tail <Expr> )

  | ( if <Expr> <Expr> <Expr> )
  | ( cond { [ <Expr> <Expr> ] } [ else <Expr> ] )

  | ( let  ( <Binding> { <Binding> } ) <Expr> )
  | ( let* ( <Binding> { <Binding> } ) <Expr> )

  | ( lambda ( <ID> { <ID> } ) <Expr> )
  | ( <Expr> <Expr> { <Expr> } )            (* application: >= 1 arg *)

  | ( add1 <Expr> )
  | ( sub1 <Expr> )
  | ( sqrt <Expr> )
  | ( expt <Expr> <Expr> )

  | ( + <Expr> <Expr> { <Expr> } )
  | ( - <Expr> <Expr> { <Expr> } )
  | ( * <Expr> <Expr> { <Expr> } )
  | ( / <Expr> <Expr> { <Expr> } )

  | ( =  <Expr> <Expr> { <Expr> } )
  | ( <  <Expr> <Expr> { <Expr> } )
  | ( >  <Expr> <Expr> { <Expr> } )
  | ( <= <Expr> <Expr> { <Expr> } )
  | ( >= <Expr> <Expr> { <Expr> } )
  | ( != <Expr> <Expr> { <Expr> } )

<Binding> ::= ( <ID> <Expr> )

<ID>   ::= [A-Za-z][A-Za-z0-9_]*
<INT>  ::= [+\-]?[0-9]+
<BOOL> ::= #t | #f
\end{lstlisting}

\subsection*{Restricciones estáticas (aridad y forma)}
\begin{itemize}
	\item Operadores variádicos \texttt{+ - * / = < > <= >= !=}: requieren al menos 2
	      argumentos.
	\item Aplicación de funciones: requiere al menos 1 argumento (\texttt{(f a [b]
		      ...)}).
	\item \texttt{lambda}: al menos 1 parámetro.
	\item \texttt{let} y \texttt{let*}: al menos 1 ligadura.
	\item \texttt{cond}: debe incluir una cláusula final \texttt{[else e]}; si aparece \texttt{else}, es la última.
\end{itemize}

\subsection*{Convenciones semánticas}
\begin{itemize}
	\item Evaluación estricta de izquierda a derecha.
	\item Operadores variádicos aritméticos (\texttt{+ - * /}): plegado izquierdo;
	      p.~ej., \texttt{(+ a b c d)} = \texttt{(((a+b)+c)+d)}. Para \texttt{/}, la
	      división es binaria iterada.
	\item Comparaciones variádicas (\texttt{< > <= >= = !=}): interpretación en cadena;
	      p.~ej., \texttt{(< a b c)} equivale a \texttt{(a<b) \&\& (b<c)}.
	\item \texttt{expt} se define binaria: \texttt{(expt base exp)}.
	\item \texttt{let}: ligaduras evaluadas en el ambiente original (paralelo). \texttt{let*}: evaluación secuencial, extendiendo el ambiente en cada paso.
	\item Listas con corchetes son azúcar sintáctica hacia un núcleo con
	      \texttt{nil/cons} o pares encadenados; por ejemplo, \texttt{[e1, e2, e3]}
	      $\Rightarrow$ \texttt{(cons e1 (cons e2 (cons e3 nil)))}.
\end{itemize}

\paragraph{Nota de diseño.}
Cada extensión debe venir acompañada de: (i) reglas de desazúcar sobre el
\textbf{ASA}, (ii) reglas SOS con nombres consistentes, y (iii) ejemplos de
derivación y pruebas unitarias que cubran casos normales y de error.

\section{Sintaxis abstracta (ASA)}

\subsection{Justificación y principios de diseño}

La \emph{Sintaxis Abstracta} (ASA) es la forma estructural del programa:
organiza las expresiones por sus subexpresiones y deja fuera detalles de la
escritura (paréntesis, comas, corchetes). Cada constructor se forma a partir de
las ASAs de sus componentes y, cuando la EBNF usa repetición {…}, en la ASA eso
se refleja como una lista (argumentos de operadores y comparadores, parámetros
de \texttt{lambda}, argumentos de aplicación, ligaduras de
\texttt{let}/\texttt{let*}, cláusulas de \texttt{cond}, elementos de listas).
Se respetan las aridades mínimas de la gramática (por ejemplo, operadores y
comparadores con n\(=>\)2, \texttt{lambda} con al menos un parámetro,
aplicación con al menos un argumento, \texttt{let}/\texttt{let*} con al menos
una ligadura) y las ligaduras quedan explícitas: los parámetros de
\texttt{lambda} y las variables de \texttt{let}/\texttt{let*} ligan en el
cuerpo. La ASA no fija el modo de evaluación; esas decisiones se precisan
después en la semántica y, cuando corresponda, en el tratamiento del azúcar y
su desazucarización.

\subsection{Reglas de formación}

% (Opcional pero útil en el preámbulo)
% \providecommand{\ASA}{\mathit{ASA}} % Si prefieres \ASA en vez de \mathrm{ASA}

\paragraph{Átomos.}
\[
	\frac{n\in\mathbb{Z}}{\mathrm{Num}(n)\ \in\ \mathrm{ASA}}
	\qquad
	\frac{b\in\{\#t,\#f\}}{\mathrm{Bool}(b)\ \in\ \mathrm{ASA}}
	\qquad
	\frac{x\in \mathrm{Id}}{\mathrm{Var}(x)\ \in\ \mathrm{ASA}}
\]

\paragraph{Aritméticos variádicos \texorpdfstring{$(+\ -\ *\ /)$} con $n\ge 2$.}
\[
	\frac{a_1\in\mathrm{ASA}\ \ \cdots\ \ a_n\in\mathrm{ASA}\ \ \ n\ge 2}
	{\mathrm{Add}_{\texttt{}}\big([a_1,\dots,a_n]\big)\ \in\ \mathrm{ASA}}
	\qquad
	\frac{a_1\in\mathrm{ASA}\ \ \cdots\ \ a_n\in\mathrm{ASA}\ \ \ n\ge 2}
	{\mathrm{Sub}_{\texttt{}}\big([a_1,\dots,a_n]\big)\ \in\ \mathrm{ASA}}
\]
\[
	\frac{a_1\in\mathrm{ASA}\ \ \cdots\ \ a_n\in\mathrm{ASA}\ \ \ n\ge 2}
	{\mathrm{Mul}{\texttt{}}\big([a_1,\dots,a_n]\big)\ \in\ \mathrm{ASA}}
	\qquad
	\frac{a_1\in\mathrm{ASA}\ \ \cdots\ \ a_n\in\mathrm{ASA}\ \ \ n\ge 2}
	{\mathrm{Div}_{\texttt{}}\big([a_1,\dots,a_n]\big)\ \in\ \mathrm{ASA}}
\]

\paragraph{Unarios y potencia.}
\[
	\frac{e\in\mathrm{ASA}}{\mathrm{Add1}(e)\ \in\ \mathrm{ASA}}
	\qquad
	\frac{e\in\mathrm{ASA}}{\mathrm{Sub1}(e)\ \in\ \mathrm{ASA}}
	\qquad
	\frac{e\in\mathrm{ASA}}{\mathrm{Sqrt}(e)\ \in\ \mathrm{ASA}}
	\qquad
	\frac{\mathrm{base}\in\mathrm{ASA}\ \ \ \mathrm{exp}\in\mathrm{ASA}}
	{\mathrm{Expt}(\mathrm{base},\mathrm{exp})\ \in\ \mathrm{ASA}}
\]

\paragraph{Predicados variádicos \texorpdfstring{$(=\ <\ >\ \le\ \ge\ $}{!=)} con $n\ge 2$.}

\[
	\frac{a_1\in\mathrm{ASA}\ \ \cdots\ \ a_n\in\mathrm{ASA}\ \ \ n\ge 2}
	{\mathrm{Igual}\big([a_1,\dots,a_n]\big)\ \in\ \mathrm{ASA}}
	\qquad
	\frac{a_1\in\mathrm{ASA}\ \ \cdots\ \ a_n\in\mathrm{ASA}\ \ \ n\ge 2}
	{\mathrm{Menorq}\big([a_1,\dots,a_n]\big)\ \in\ \mathrm{ASA}}
\]
\[
	\frac{a_1\in\mathrm{ASA}\ \ \cdots\ \ a_n\in\mathrm{ASA}\ \ \ n\ge 2}
	{\mathrm{Mayorq}\big([a_1,\dots,a_n]\big)\ \in\ \mathrm{ASA}}
	\qquad
	\frac{a_1\in\mathrm{ASA}\ \ \cdots\ \ a_n\in\mathrm{ASA}\ \ \ n\ge 2}
	{\mathrm{MenorIgu}\big([a_1,\dots,a_n]\big)\ \in\ \mathrm{ASA}}
\]
\[
	\frac{a_1\in\mathrm{ASA}\ \ \cdots\ \ a_n\in\mathrm{ASA}\ \ \ n\ge 2}
	{\mathrm{MayorIgu}\big([a_1,\dots,a_n]\big)\ \in\ \mathrm{ASA}}
	\qquad
	\frac{a_1\in\mathrm{ASA}\ \ \cdots\ \ a_n\in\mathrm{ASA}\ \ \ n\ge 2}
	{\mathrm{NoIgual}\big([a_1,\dots,a_n]\big)\ \in\ \mathrm{ASA}}
\]

\paragraph{Pares y proyecciones.}
\[
	\frac{e_1\in\mathrm{ASA}\ \ \ e_2\in\mathrm{ASA}}
	{\mathrm{Par}(e_1,e_2)\ \in\ \mathrm{ASA}}
	\qquad
	\frac{e\in\mathrm{ASA}}{\mathrm{Fst}(e)\ \in\ \mathrm{ASA}}
	\qquad
	\frac{e\in\mathrm{ASA}}{\mathrm{Snd}(e)\ \in\ \mathrm{ASA}}
\]

\paragraph{Listas y operaciones.}
\[
	\frac{e_1\in\mathrm{ASA}\ \ \cdots\ \ e_n\in\mathrm{ASA}\ \ \ n\ge 0}
	{\mathrm{Lista}([e_1,\dots,e_n])\ \in\ \mathrm{ASA}}
	\qquad
	\frac{e\in\mathrm{ASA}}{\mathrm{Head}(e)\ \in\ \mathrm{ASA}}
	\qquad
	\frac{e\in\mathrm{ASA}}{\mathrm{Tail}(e)\ \in\ \mathrm{ASA}}
\]

\paragraph{Condicionales.}
\[
	\frac{t\in\mathrm{ASA}\ \ \ \mathrm{th}\in\mathrm{ASA}\ \ \ \mathrm{el}\in\mathrm{ASA}}
	{\mathrm{If}(t,\mathrm{th},\mathrm{el})\ \in\ \mathrm{ASA}}
\]
\[
	\frac{g_1\in\mathrm{ASA}\ \ e_1\in\mathrm{ASA}\ \ \cdots\ \ g_r\in\mathrm{ASA}\ \ e_r\in\mathrm{ASA}\ \ \ \mathrm{el}\in\mathrm{ASA}\ \ \ r\ge 1}
	{\mathrm{Cond}\big([(g_1,e_1),\dots,(g_r,e_r)],\ \mathrm{el}\big)\ \in\ \mathrm{ASA}}
\]

\paragraph{Asignaciones locales.}
\[
	\frac{x_1\in \mathrm{Id},\ e_1\in\mathrm{ASA}\ \ \cdots\ \ x_k\in \mathrm{Id},\ e_k\in\mathrm{ASA}\ \ \ \mathrm{body}\in\mathrm{ASA}\ \ \ k\ge 1}
	{\mathrm{Let}\big([(x_1,e_1),\dots,(x_k,e_k)],\ \mathrm{body}\big)\ \in\ \mathrm{ASA}}
\]
\[
	\frac{x_1\in \mathrm{Id},\ e_1\in\mathrm{ASA}\ \ \cdots\ \ x_k\in \mathrm{Id},\ e_k\in\mathrm{ASA}\ \ \ \mathrm{body}\in\mathrm{ASA}\ \ \ k\ge 1}
	{\mathrm{\texttt{let*}}\big([(x_1,e_1),\dots,(x_k,e_k)],\ \mathrm{body}\big)\ \in\ \mathrm{ASA}}
\]

\paragraph{Funciones anónimas y aplicación.}
\[
	\frac{x_1\in \mathrm{Id}\ \ \cdots\ \ x_n\in \mathrm{Id}\ \ \ \mathrm{c}\in\mathrm{ASA}\ \ \ n\ge 1}
	{\mathrm{Lambda}\big([x_1,\dots,x_n],\ \mathrm{c}\big)\ \in\ \mathrm{ASA}}
	\qquad
	\frac{f\in\mathrm{ASA}\ \ a_1\in\mathrm{ASA}\ \ \cdots\ \ a_m\in\mathrm{ASA}\ \ \ m\ge 1}
	{\mathrm{App}(f,\ [a_1,\dots,a_m])\ \in\ \mathrm{ASA}}
\]

\section{Desazucarización}

\subsection{Núcleo (core) propuesto}

\paragraph{Objetivo.}
Un núcleo pequeño, determinista y estricto (CBV izquierda$\to$derecha), con
\emph{lambda} y aplicación \emph{unarias}, condicional booleano, pares/listas,
primitivas binarias para aritmética/comparación, y un operador de punto fijo.

\paragraph{Constructores del núcleo (ASA-Core).}
\[
	\begin{array}{rcl}
		\text{Atómicos}     & : & \Num(n),\ \Bool(b),\ \Var(x)                                                          \\[2pt]
		\text{Funciones}    & : & \Lam(x,\, e)                                                                          \\[2pt]
		\text{Aplicación}   & : & \App(e_1,\, e_2)                                                                      \\[2pt]
		\text{Condicional}  & : & \If(c,\, t,\, e)                                                                      \\[2pt]
		\text{Pares/Listas} & : & \Pair(e_1, e_2),\ \Fst(e),\ \Snd(e),\ \Nil                                            \\[2pt]
		\text{Num. binario} & : &
		\PrimAdd(e_1,e_2),\ \PrimSub(e_1,e_2),\ \PrimMul(e_1,e_2),\ \PrimDiv(e_1,e_2),                                  \\
		                    &   & \PrimExpt(e_1,e_2),\ \PrimSqrt(e)\ \text{(unaria)}                                    \\[2pt]
		\text{Cmp. binario} & : &
		\PrimEq(e_1,e_2),\ \PrimLt(e_1,e_2),\ \PrimGt(e_1,e_2),\ \PrimLe(e_1,e_2),\ \PrimGe(e_1,e_2),\ \PrimNe(e_1,e_2) \\[2pt]
		\text{Fijo}         & : & \Fix(e) \quad (\text{punto fijo})
	\end{array}
\]

\paragraph{Convenciones SOS (alto nivel).}
Evaluación \emph{call-by-value}, izquierda$\to$derecha, con reglas estándar:
\[
	\begin{array}{l}
		\App(\Lam(x,b),\, v)\ \to\ b[x:=v] \qquad
		\If(\Bool(\#t),\, t,\, e)\to t \quad
		\If(\Bool(\#f),\, t,\, e)\to e              \\[2pt]
		\Fix(\Lam(x,b))\ \to\ b[x:=\Fix(\Lam(x,b))] \\[2pt]
		\text{Primitivas reducen sobre valores apropiados (enteros/booleanos/pares).}
	\end{array}
\]
Los errores dinámicos (tipo, división por cero, \texttt{head} de \texttt{Nil},
etc.) quedan definidos en la especificación de ejecución.

\subsection{Notación de traducción}
Denotamos por $\llbracket e \rrbracket$ la transformación de
\textbf{superficie} a \textbf{núcleo} sobre ASA.

\subsection{Reglas básicas}
\[
	\begin{array}{rclcrcl}
		\llbracket n \rrbracket   & = & \Num(n)    & \qquad &
		\llbracket \#t \rrbracket & = & \Bool(\#t)            \\[2pt]
		\llbracket \#f \rrbracket & = & \Bool(\#f) &        &
		\llbracket x \rrbracket   & = & \Var(x)
	\end{array}
\]

\subsection{Lambdas variádicas y aplicación multi-argumento (currificación)}

\paragraph{Lambda.}
\[
	\llbracket (\lambda\ (x_1\ \dots\ x_n)\ e) \rrbracket
	\ =\ \Lam(x_1,\ \Lam(x_2,\ \dots\ \Lam(x_n,\ \llbracket e\rrbracket)\dots))
	\quad (n\ge 1)
\]

\paragraph{Aplicación.}
\[
	\llbracket (f\ a_1\ \dots\ a_m) \rrbracket
	\ =\ \App(\dots \App(\App(\llbracket f\rrbracket,\ \llbracket a_1\rrbracket),\ \llbracket a_2\rrbracket)\dots,\ \llbracket a_m\rrbracket)
	\quad (m\ge 1)
\]

\subsection{\texttt{let}, \texttt{let*} y \texttt{letrec}}

\paragraph{\texttt{let} paralelo.}
\[
	\llbracket (\texttt{let}\ ((x_1\ e_1)\dots(x_n\ e_n))\ b) \rrbracket
	\ =\ \llbracket ((\lambda (x_1\dots x_n)\ b)\ e_1\ \dots\ e_n)\rrbracket
	\quad (n\ge 1)
\]

\paragraph{\texttt{let*} secuencial.}
\[
	\begin{array}{rcl}
		\llbracket (\texttt{let*}\ ((x\ e)\ \vec{bs})\ b) \rrbracket
		 & = & \llbracket (\texttt{let}\ ((x\ e))\ (\texttt{let*}\ (\vec{bs})\ b)) \rrbracket \\[4pt]
		\llbracket (\texttt{let*}\ ((x\ e))\ b) \rrbracket
		 & = & \llbracket (\texttt{let}\ ((x\ e))\ b) \rrbracket
	\end{array}
\]

\paragraph{\texttt{letrec} unario.}
\[
	\llbracket (\texttt{letrec}\ (x\ e)\ b) \rrbracket
	\ =\ \llbracket (\texttt{let}\ ((x\ \Fix(\lambda(x)\ e)))\ b) \rrbracket
\]

\subsection{Condicionales: \texttt{if}, \texttt{if0}, \texttt{cond}}

\paragraph{\texttt{if} (primitiva).}
\[
	\llbracket (\texttt{if}\ c\ t\ e) \rrbracket\ =\ \If(\llbracket c\rrbracket,\ \llbracket t\rrbracket,\ \llbracket e\rrbracket)
\]

\paragraph{\texttt{if0} (azúcar).}
\[
	\llbracket (\texttt{if0}\ e\ t\ f) \rrbracket\ =\ \If(\PrimEq(\llbracket e\rrbracket,\ \Num(0)),\ \llbracket t\rrbracket,\ \llbracket f\rrbracket)
\]

\paragraph{\texttt{cond} con \texttt{else}.}
\[
	\llbracket (\texttt{cond}\ [g_1\ e_1]\ \dots\ [g_r\ e_r]\ [\texttt{else}\ e_0]) \rrbracket
	= \If(\llbracket g_1\rrbracket,\ \llbracket e_1\rrbracket,\ \dots\If(\llbracket g_r\rrbracket,\ \llbracket e_r\rrbracket,\ \llbracket e_0\rrbracket)\dots)
	\quad (r\ge 1)
\]

\subsection{Aritmética variádica y unarios}

\paragraph{Plegado izquierdo (n$\ge$2).}
Sea
\[
	\foldL(\oplus,\ [a_1,\dots,a_n])\ =\ \oplus(\dots \oplus(\oplus(a_1,a_2),a_3)\dots,a_n).
\]
Entonces
\[
	\begin{array}{rcl}
		\llbracket (+\ e_1\ \dots\ e_n) \rrbracket & = & \foldL(\PrimAdd,\ [\llbracket e_1\rrbracket,\dots,\llbracket e_n\rrbracket]) \\
		\llbracket (-\ e_1\ \dots\ e_n) \rrbracket & = & \foldL(\PrimSub,\ [\llbracket e_1\rrbracket,\dots,\llbracket e_n\rrbracket]) \\
		\llbracket (*\ e_1\ \dots\ e_n) \rrbracket & = & \foldL(\PrimMul,\ [\llbracket e_1\rrbracket,\dots,\llbracket e_n\rrbracket]) \\
		\llbracket (/\ e_1\ \dots\ e_n) \rrbracket & = & \foldL(\PrimDiv,\ [\llbracket e_1\rrbracket,\dots,\llbracket e_n\rrbracket])
	\end{array}
	\quad (n\ge 2)
\]

\paragraph{Unarios y potencia.}
\[
	\begin{array}{rclcrcl}
		\llbracket (\texttt{add1}\ e) \rrbracket    & =      & \PrimAdd(\llbracket e\rrbracket,\ \Num(1))
		                                            & \qquad &
		\llbracket (\texttt{sub1}\ e) \rrbracket    & =      & \PrimSub(\llbracket e\rrbracket,\ \Num(1))                 \\[2pt]
		\llbracket (\texttt{sqrt}\ e) \rrbracket    & =      & \PrimSqrt(\llbracket e\rrbracket)
		                                            &        &
		\llbracket (\texttt{expt}\ b\ e) \rrbracket & =      & \PrimExpt(\llbracket b\rrbracket,\ \llbracket e\rrbracket)
	\end{array}
\]

\subsection{Comparadores variádicos}

\paragraph{Esquema de cadena con cortocircuito.}
Definimos, por notación metalingüística,
\[
	\chain(\odot,\ [a_1,\dots,a_n])\ =\
	\If(\odot(a_1,a_2),\ \chain(\odot,\ [a_2,\dots,a_n]),\ \Bool(\#f)),
	\quad
	\chain(\odot,\ [a,b])=\odot(a,b).
\]

\[
	\begin{array}{rcl}
		\llbracket (= \ e_1 \dots e_n) \rrbracket   & = & \chain(\PrimEq,\ [\llbracket e_1\rrbracket,\dots,\llbracket e_n\rrbracket]) \\
		\llbracket (< \ e_1 \dots e_n) \rrbracket   & = & \chain(\PrimLt,\ [\llbracket e_1\rrbracket,\dots,\llbracket e_n\rrbracket]) \\
		\llbracket (> \ e_1 \dots e_n) \rrbracket   & = & \chain(\PrimGt,\ [\llbracket e_1\rrbracket,\dots,\llbracket e_n\rrbracket]) \\
		\llbracket (\le\ e_1 \dots e_n) \rrbracket  & = & \chain(\PrimLe,\ [\llbracket e_1\rrbracket,\dots,\llbracket e_n\rrbracket]) \\
		\llbracket (\ge\ e_1 \dots e_n) \rrbracket  & = & \chain(\PrimGe,\ [\llbracket e_1\rrbracket,\dots,\llbracket e_n\rrbracket]) \\
		\llbracket (\neq\ e_1 \dots e_n) \rrbracket & = & \chain(\PrimNe,\ [\llbracket e_1\rrbracket,\dots,\llbracket e_n\rrbracket])
	\end{array}
	\quad (n\ge 2)
\]

\subsection{Pares y listas}

\paragraph{Pares y proyecciones.}
\[
	\llbracket (e_1, e_2) \rrbracket=\Pair(\llbracket e_1\rrbracket,\ \llbracket e_2\rrbracket),\quad
	\llbracket (\texttt{fst}\ e) \rrbracket=\Fst(\llbracket e\rrbracket),\quad
	\llbracket (\texttt{snd}\ e) \rrbracket=\Snd(\llbracket e\rrbracket).
\]

\paragraph{Listas con corchetes y operaciones.}
\[
	\text{\texttt{[]}}\ \Rightarrow\ \Nil,\qquad
	\text{\texttt{[}}\,e_1,\dots,e_n\text{\texttt{]}}\ \Rightarrow\
	\Pair(\llbracket e_1\rrbracket,\ \dots\ \Pair(\llbracket e_n\rrbracket,\ \Nil)\dots).
\]
\[
	\llbracket (\texttt{head}\ e) \rrbracket\ =\ \Fst(\llbracket e\rrbracket),\qquad
	\llbracket (\texttt{tail}\ e) \rrbracket\ =\ \Snd(\llbracket e\rrbracket).
\]

\subsection{Ejemplos de desazucarización}

\paragraph{Aplicación curriﬁcada.}
\[
	\begin{aligned}
		\llbracket ((\lambda (x\,y\,z)\ (+\ x\ y\ z))\ 1\ 2\ 3) \rrbracket
		 & =\ \App(\App(\App(\Lam(x,\Lam(y,\Lam(z,\,\llbracket (+\ x\ y\ z)\rrbracket))),\ \Num(1)),\ \Num(2)),\ \Num(3)) \\
		\llbracket (+\ x\ y\ z) \rrbracket
		 & =\ \PrimAdd(\PrimAdd(\llbracket x\rrbracket,\ \llbracket y\rrbracket),\ \llbracket z\rrbracket)
	\end{aligned}
\]

\paragraph{\texttt{let} paralelo vs \texttt{let*} secuencial.}
\[
	\begin{aligned}
		\llbracket (\texttt{let}\ ((x\ 1)(y\ (+\ x\ 1)))\ (+\ x\ y)) \rrbracket
		 & =\ \llbracket ((\lambda (x\ y)\ (+\ x\ y))\ 1\ (+\ x\ 1)) \rrbracket                            \\[4pt]
		\llbracket (\texttt{let*}\ ((x\ 1)(y\ (+\ x\ 1)))\ (+\ x\ y)) \rrbracket
		 & =\ \llbracket (\texttt{let}\ ((x\ 1))\ (\texttt{let*}\ ((y\ (+\ x\ 1)))\ (+\ x\ y))) \rrbracket
	\end{aligned}
\]

\paragraph{\texttt{cond} en \texttt{if} anidados.}
\[
	\llbracket (\texttt{cond}\ [g_1\ e_1]\ [g_2\ e_2]\ [\texttt{else}\ e_0]) \rrbracket
	=\If(\llbracket g_1\rrbracket,\ \llbracket e_1\rrbracket,\ \If(\llbracket g_2\rrbracket,\ \llbracket e_2\rrbracket,\ \llbracket e_0\rrbracket)).
\]

\paragraph{Comparación encadenada (ejemplo).}
\[
	\llbracket (\ge\ a\ b\ c\ d) \rrbracket
	=\If(\PrimGe(\llbracket a\rrbracket,\llbracket b\rrbracket),\
	\If(\PrimGe(\llbracket b\rrbracket,\llbracket c\rrbracket),\
		\PrimGe(\llbracket c\rrbracket,\llbracket d\rrbracket),\
		\Bool(\#f)),\
	\Bool(\#f)).
\]

\subsection{Esbozo de contextos de evaluación (para SOS-CBV)}
\[
	\begin{array}{rcl}
		E & ::= & [\ ] \mid \App(E, e) \mid \App(v, E) \mid \If(E, e, e)       \\
		  &     & \mid\ \Prim(\_, E, e) \mid \Prim(\_, v, E) \mid \PrimSqrt(E) \\
		  &     & \mid\ \Pair(E, e) \mid \Pair(v, E) \mid \Fst(E) \mid \Snd(E)
	\end{array}
\]
donde $v$ son valores: $\Num(n)$, $\Bool(b)$, $\Lam(x,e)$, $\Nil$,
$\Pair(v_1,v_2)$.

\subsection{Resumen (``cheat-sheet'')}

\paragraph{Lambdas y apps.}
\[
	\begin{array}{l}
		(\lambda (x_1\dots x_n)\ e)\ \Rightarrow\ \Lam(x_1,\dots\Lam(x_n,\llbracket e\rrbracket)\dots) \\
		(f\ a_1\dots a_m)\ \Rightarrow\ \text{aplicación unaria izquierda-asociativa}
	\end{array}
\]

\paragraph{\texttt{let}/\texttt{let*}/\texttt{letrec}.}
\[
	\begin{array}{l}
		(\texttt{let}\ ((x_1 e_1)\dots(x_n e_n))\ b)\ \Rightarrow\ ((\lambda (x_1\dots x_n)\ b)\ e_1\dots e_n) \\
		(\texttt{let*}\ ((x\ e)\ \vec{bs})\ b)\ \Rightarrow\ (\texttt{let}\ ((x\ e))\ (\texttt{let*}\ (\vec{bs})\ b)),\
		(\texttt{let*}\ ((x\ e))\ b)\ \Rightarrow\ (\texttt{let}\ ((x\ e))\ b)                                 \\
		(\texttt{letrec}\ (x\ e)\ b)\ \Rightarrow\ (\texttt{let}\ ((x\ \Fix(\lambda(x)\ e)))\ b)
	\end{array}
\]

\paragraph{Condicionales.}
\[
	\begin{array}{l}
		(\texttt{if}\ c\ t\ e)\ \Rightarrow\ \If(\llbracket c\rrbracket,\llbracket t\rrbracket,\llbracket e\rrbracket)                   \\
		(\texttt{if0}\ e\ t\ f)\ \Rightarrow\ \If(\PrimEq(\llbracket e\rrbracket,\Num(0)),\llbracket t\rrbracket,\llbracket f\rrbracket) \\
		(\texttt{cond}\ [g_i e_i]\,\dots\,[\texttt{else}\ e_0])\ \Rightarrow\ \text{\texttt{if} anidados}
	\end{array}
\]

\paragraph{Aritmética y unarios.}
\[
	\begin{array}{l}
		(+|{-}|*|/\, e_1\dots e_n)\ \Rightarrow\ \foldL(\PrimAdd|\PrimSub|\PrimMul|\PrimDiv,\ [\llbracket e_i\rrbracket]) \\
		(\texttt{add1}\ e)\Rightarrow\PrimAdd(\llbracket e\rrbracket,\Num(1)),\quad
		(\texttt{sub1}\ e)\Rightarrow\PrimSub(\llbracket e\rrbracket,\Num(1))                                             \\
		(\texttt{sqrt}\ e)\Rightarrow\PrimSqrt(\llbracket e\rrbracket),\quad
		(\texttt{expt}\ b\ e)\Rightarrow\PrimExpt(\llbracket b\rrbracket,\llbracket e\rrbracket)
	\end{array}
\]

\paragraph{Comparadores en cadena.}
\[
	(<op>\ e_1\dots e_n)\ \Rightarrow\ \chain(\Prim<op>,\ [\llbracket e_i\rrbracket])\quad(n\ge 2)
\]

\paragraph{Pares y listas.}
\[
	\begin{array}{l}
		\mathopen{(}e_1, e_2\mathclose{)}\ \Rightarrow\ \Pair(\llbracket e_1\rrbracket,\llbracket e_2\rrbracket),\quad
		\texttt{fst}/\texttt{snd}\ \Rightarrow\ \Fst/\Snd
		\\[4pt]
		\mathopen{[}\mathclose{]}\ \Rightarrow\ \Nil,\quad
		\mathopen{[}\ e_1,\dots,e_n\ \mathclose{]}\ \Rightarrow\
				\Pair(\llbracket e_1\rrbracket,\ \dots\ \Pair(\llbracket e_n\rrbracket,\ \Nil)\dots)
		\\[4pt]
		\llbracket (\texttt{head}\ e) \rrbracket\ \Rightarrow\ \Fst(\llbracket e\rrbracket),\quad
		\llbracket (\texttt{tail}\ e) \rrbracket\ \Rightarrow\ \Snd(\llbracket e\rrbracket)
	\end{array}
\]
