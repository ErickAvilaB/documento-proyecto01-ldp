% ---------- Cuerpo del documento ----------

% Titulo
\begin{center}
	% Nombre de la tarea
	\huge
	\tareaName

	% Nombre del autor
	\vspace{0.5cm}
	\large
	Avila Barba Erick Yahir\\
	Galvan Cordoba Uriel Federico\\
	Hernandez Coronel Angel Carlos

	% Fecha
	\vspace{0.3cm}
	\large
	\fecha
\end{center}
\vspace{0.5cm}

\section{Introducción: motivación, objetivos y delimitación del proyecto}

\subsection*{Motivación}
Este proyecto nace para tender un puente claro entre la teoría de lenguajes de
programación y su implementación real. A partir de un lenguaje pequeño tipo
\emph{MiniLisp}, buscamos mostrar cómo las piezas formales (léxico, gramática,
sintaxis abstracta y reglas de evaluación) se traducen en un sistema
ejecutable. El objetivo es que el lector pueda recorrer el ciclo completo: del
papel al programa que corre, entendiendo qué se gana (y qué se pierde) en cada
decisión de diseño.

\subsection*{Objetivos}
\begin{itemize}
	\item \textbf{Formalizar} el lenguaje de superficie y su \emph{core}: léxico, EBNF, Árbol de Sintaxis Abstracta (ASA) y reglas de desazúcar bien especificadas.
	\item \textbf{Definir} la semántica operacional (paso pequeño) para las construcciones del núcleo, con nombres de reglas consistentes y ejemplos de derivación.
	\item \textbf{Implementar} un prototipo funcional en Haskell.
	\item \textbf{Cubrir} las extensiones indicadas en el enunciado (operadores y predicados variádicos, nuevos aritméticos, pares, listas, \texttt{let}/\texttt{let*}/\texttt{letrec}, \texttt{if}/\texttt{if0}, \texttt{cond}, lambdas y aplicación a múltiples argumentos), dejando claro qué es superficie y qué es núcleo.
	\item \textbf{Acompañar} la implementación con casos de prueba y pequeños programas ejemplo (p.\,ej., suma de los primeros $n$, factorial, Fibonacci, \texttt{map}/\texttt{filter}).
\end{itemize}

\subsection*{Delimitación}
Para mantener el alcance razonable y alineado con los objetivos docentes, este
proyecto:
\begin{itemize}
	\item Se enfoca en \textbf{un solo paradigma} (funcional, estilo Lisp) con
	      \textbf{semántica por sustitución/ambientes} y sin efectos laterales complejos.
	\item Incluye \textbf{enteros}, \textbf{booleanos}, \textbf{funciones de primera
		      clase}, \textbf{pares} y \textbf{listas}; \textbf{no} aborda estructuras
	      avanzadas (registros, objetos) ni módulos.
	\item Trabaja con \textbf{evaluación determinista} y especifica \textbf{puntos
		      estrictos} cuando aplique; quedan fuera temas como \textbf{concurrencia},
	      \textbf{paralelismo} y \textbf{laziness global} del runtime.
	\item Define \textbf{errores léxicos/sintácticos} y \textbf{dinámicos básicos}
	      (p.\,ej., tipos incompatibles, aplicación de no-función), pero \textbf{no}
	      implementa un sistema de tipos estático avanzado.
	\item Usa \textbf{Alex} y \textbf{Happy} como herramientas de \textbf{Haskell}.
	\item Prioriza \textbf{claridad}: toda característica de superficie tiene una
	      traducción explícita al núcleo y reglas de evaluación correspondientes.
\end{itemize}

% --- Símbolos para la gramática (categorías y no terminales)
\newcommand{\Id}{\mathit{Id}}
\newcommand{\Int}{\mathit{Int}}
\newcommand{\Bool}{\mathit{Bool}}
\newcommand{\Expr}{\mathit{Expr}}

\section{Gramática base y extensiones solicitadas}

\subsection*{Gramática base}
La siguiente gramática define el lenguaje \emph{MiniLisp} de
\textbf{superficie} antes del desazúcar. Se muestran las categorías léxicas
mínimas y la sintaxis concreta de las construcciones base.

\paragraph{Categorías léxicas.}
\[
	\begin{array}{rcl}
		\Id   & ::= & \text{identificador}                                                      \\
		\Int  & ::= & \text{entero decimal (sin ceros a la izquierda, opcionalmente con signo)} \\
		\Bool & ::= & \#t \mid \#f
	\end{array}
\]

\paragraph{Expresiones.}
\[
	\begin{array}{rcl}
		\Expr & ::=  & \Id \mid \Int \mid \Bool                 \\
		      & \mid & (+\ \Expr\ \Expr) \mid (-\ \Expr\ \Expr) \\
		      & \mid & (not\ \Expr)                             \\
		      & \mid & (let\ (\Id\ \Expr)\ \Expr)               \\
		      & \mid & (letrec\ (\Id\ \Expr)\ \Expr)            \\
		      & \mid & (if0\ \Expr\ \Expr\ \Expr)               \\
		      & \mid & (lambda\ (\Id)\ \Expr)                   \\
		      & \mid & (\Expr\ \Expr) \quad \text{(aplicación)}
	\end{array}
\]

\paragraph{Convenciones.}
\begin{itemize}
	\item La aplicación $(\Expr\ \Expr)$ asocia a la \emph{izquierda}: $(((e_1\ e_2)\
		      e_3)\ \dots)$.
	\item Esta gramática es de \textbf{superficie}; en el \emph{núcleo} se empleará un
	      conjunto mínimo de constructores y desazúcar sistemático.
\end{itemize}

\subsection*{Extensiones solicitadas}
Además de la gramática base, el proyecto requiere incorporar y especificar
formalmente las siguientes funcionalidades. Cada una deberá precisarse léxica y
sintácticamente (EBNF), desazucar a núcleo cuando aplique y contar con reglas
SOS (paso pequeño):

\begin{enumerate}
	\item \textbf{Operadores variádicos} (mínimo 2 argumentos) para aritmética y predicados; documentar orden de evaluación y regla de reducción (plegado).
	\item \textbf{Aritméticos nuevos}: \texttt{*}, \texttt{/} (variádicos), \texttt{add1}, \texttt{sub1}, \texttt{sqrt}, \texttt{expt}.
	\item \textbf{Predicados numéricos} variádicos: \texttt{=}, \texttt{<}, \texttt{>}, \texttt{>=}, \texttt{<=}, \texttt{!=}; aclarar si operan en \emph{cadena} ($x_1 \odot x_2 \odot \dots \odot x_n$) o por pares.
	\item \textbf{Pares y proyecciones}: constructor de pareja $(e_1, e_2)$ y selectores \texttt{fst}, \texttt{snd}.
	\item \textbf{\texttt{let} y \texttt{let*} variádicos}: múltiples asignaciones; \texttt{let} paralelo (sin dependencias cruzadas) y \texttt{let*} secuencial (permite dependencias).
	\item \textbf{Condicional booleano} \texttt{(if e1 e2 e3)} y su relación con \texttt{if0} (decidir primitiva o azúcar).
	\item \textbf{Listas con corchetes} y operaciones: literales \texttt{[e, ...]}, \texttt{head}, \texttt{tail}, y lista vacía \texttt{[]}; definir si son homogéneas y su traducción (p.\,ej., a \texttt{nil}/\texttt{cons} o a pares anidados).
	\item \textbf{\texttt{cond} con \texttt{else}}: cláusulas ordenadas \texttt{[guard expr]} \dots \texttt{[else expr]} con reglas claras para el último caso.
	\item \textbf{Lambdas variádicas} y \textbf{aplicación con múltiples argumentos}: \texttt{(lambda (x y z) e)} y \texttt{(f a b c)}; precisar semántica y desazúcar (p.\,ej., currificación) hacia el núcleo unario.
\end{enumerate}

\section{Desarrollo de la Sintaxis}

Esta sección define con precisión la \emph{sintaxis léxica} (clases de tokens,
manejo de espacios y comentarios) y la \emph{gramática concreta} (EBNF) del
lenguaje. A continuación se justifican todas las decisiones de diseño y se
describe la semántica informal de las extensiones requeridas (operadores
variádicos, nuevos operadores aritméticos, predicados, pares, asignaciones
locales, condicionales, listas, \texttt{cond} y \texttt{lambda}).

\subsection{Álgebra de caracteres, espacios en blanco y comentarios}

\paragraph{Conjunto de caracteres.} Se asume Unicode (UTF-8) para el código fuente. Para simplificar la
especificación léxica, las clases \texttt{letra} y \texttt{dígito} se definen
sobre ASCII básico, con extensibilidad a letras Unicode si se desea.

\paragraph{Espacios en blanco.} Los espacios en blanco (blancos, tabuladores, saltos de línea, retornos de
carro) separan tokens, pero no se tokenizan. Se ignoran fuera de literales
numéricos y simbología. Regla léxica (informal):
\[
	\textit{WS} ::= [\texttt{\textbackslash t}\ \texttt{\textbackslash r}\ \texttt{\textbackslash n}\ ]^+
\]

\paragraph{Comentarios.} Se soportan dos formas:
\begin{itemize}
	\item \emph{De línea}: del carácter \texttt{;} hasta el fin de línea.
	\item \emph{De bloque anidados}: \texttt{\#|} \ldots \texttt{|\#}. Los bloques pueden anidarse; el analizador debe llevar un contador de anidación.
\end{itemize}
Expresiones regulares (informales):
\[
	\textit{COM\_LINE} ::= \texttt{;}[^\texttt{\textbackslash n}]^*\qquad
	\textit{COM\_BLOCK} ::= \texttt{\#|}(\ \text{cualquier cosa o bloque anidado}\ )^*\texttt{|\#}
\]
Los comentarios se tratan como \emph{espacios} a efectos de separación de
tokens.

\subsection{Clases de tokens (definiciones formales con ER)}

En las ER, el guion bajo se escribe \texttt{\_}, y los cuantificadores
\texttt{+} y \texttt{*} tienen su significado habitual.

\begin{center}
	\begin{tabular}{|l|l|p{8.8cm}|}
		\hline
		\textbf{Categoría}     & \textbf{Token / Lexema}                                                                       & \textbf{ER / Observaciones}                                                                                                                                                     \\
		\hline
		Paréntesis             & \texttt{(} \ \texttt{)}                                                                       & Literales de un carácter.                                                                                                                                                       \\
		\hline
		Corchetes de lista     & \texttt{[} \ \texttt{]}                                                                       & Literales de un carácter.                                                                                                                                                       \\
		\hline
		Separadores            & \texttt{,}                                                                                    & Coma literal (para pares y elementos de listas).                                                                                                                                \\
		\hline
		Operadores aritméticos & \texttt{+}\ \texttt{-}\ \texttt{*}\ \texttt{/}                                                & Literales de un carácter. Variádicos (aridad $\geq 2$).                                                                                                                         \\
		\hline
		Predicados aritméticos & \texttt{=}\ \texttt{<}\ \texttt{>}\ \texttt{<=}\ \texttt{>=}\ \texttt{!=}                     & Tokens de dos caracteres con máximo munch.                                                                                                                                      \\
		\hline
		Palabras reservadas    & \texttt{lambda, let, let*, if, if0, cond, else, fst, snd, head, tail, add1, sub1, sqrt, expt} & Reconocidas como keywords y no aceptadas como identificadores.                                                                                                                  \\
		\hline
		Booleanos              & \texttt{\#t}\ /\ \texttt{\#f}                                                                 & Literales booleanos.                                                                                                                                                            \\
		\hline
		Enteros con signo      & \texttt{INT}                                                                                  & \texttt{[+-]?[0-9]+} (el signo se permite solo si el token aparece como literal; los operadores \texttt{+}/\texttt{-} se tokenizan por separado cuando actúan como operadores). \\
		\hline
		Identificadores        & \texttt{ID}                                                                                   & \texttt{[A-Za-z][A-Za-z0-9\_\-?*!\$\%<>/=]*} excluyendo las palabras reservadas.                                                                                                \\
		\hline
	\end{tabular}
\end{center}

\paragraph{Máximo munch y ambigüedades.} Se aplica la política de mayor coincidencia: por ejemplo \texttt{>=} se
reconoce como un único token de comparación, no como \texttt{>} \texttt{=}. El
signo \texttt{-} delante de dígitos se incorpora al literal solo si aparece sin
espacio con el número y en posición donde no pueda ser un operador; esto evita
ambigüedades entre \texttt{-3} y \texttt{(- 3)}.

\subsection{Gramática concreta (EBNF)}

Usamos una EBNF orientada a S-expressions con azúcares para pares y listas. La
notación \texttt{X\^{+}} significa ``uno o más'', y \texttt{X\^{2+}} ``dos o
más''.

\begin{verbatim}
Program      ::= Expr

Expr         ::= Atom
               | "(" OpVariad Expr Expr ExprListTail ")"          // operadores variadicos aritmeticos
               | "(" PredVariad Expr Expr ExprListTail ")"        // predicados variadicos
               | "(" UnPrim   Expr ")"                            // primitivos unarios
               | "(" "fst" Expr ")" | "(" "snd" Expr ")"          // proyecciones
               | "(" "let"  "(" BindList1p ")" Expr ")"           // let paralelo
               | "(" "let*" "(" BindList1p ")" Expr ")"           // let* secuencial
               | "(" "if"   Expr Expr Expr ")"                    // condicional
               | "(" "if0"  Expr Expr Expr ")"                    // azucar; ver semantica
               | "(" "cond" ClauseList1p ")"                      // cond con else
               | "(" "lambda" "(" ParamList1p ")" Expr ")"        // funciones anonimas
               | "(" Expr Expr ExprListTail ")"                   // aplicacion general
               | PairExpr                                         // (e1, e2)
               | ListExpr                                         // [e1, ..., en] | []

Atom         ::= INT | BOOL | ID

OpVariad     ::= "+" | "-" | "*" | "/"
PredVariad   ::= "=" | "<" | ">" | "<=" | ">=" | "!="
UnPrim       ::= "add1" | "sub1" | "sqrt" | "expt"                 // expt se usa aridad 2; ver semantica

ExprListTail ::= /* vacio */ | Expr ExprListTail                   // Expr*
BindList1p   ::= Bind | Bind BindListTail
BindListTail ::= /* vacio */ | Bind BindListTail
Bind         ::= "(" ID Expr ")"

ParamList1p  ::= ID | ID ParamListTail
ParamListTail::= /* vacio */ | ID ParamListTail

ClauseList1p ::= Clause | Clause ClauseListTail
ClauseListTail::= /* vacio */ | Clause ClauseListTail
Clause       ::= "[" Expr Expr "]" | "[" "else" Expr "]"

PairExpr     ::= "(" Expr "," Expr ")"
ListExpr     ::= "[" ListElemsOpt "]"
ListElemsOpt ::= /* vacio */ | Expr ListElemsTail
ListElemsTail::= /* vacio */ | "," Expr ListElemsTail
\end{verbatim}

\paragraph{Observaciones de diseño.}
\begin{itemize}
	\item Los operadores variádicos exigen al menos dos argumentos (\texttt{Expr Expr
		      ExprListTail}); esto fuerza aridad $\geq 2$ en \texttt{+ - * /} y en los
	      predicados.
	\item \texttt{expt} se usa con aridad dos (\texttt{(expt b e)}); su reconocimiento como \texttt{UnPrim} es una convención de tokenización, la aplicación concreta se hace como aplicación general.
	\item \textbf{Azúcar de pares y listas}: \texttt{(e\_1, e\_2)} y \texttt{[e\_1, \dots, e\_n]} son notaciones no S-exp que el lexer reconoce con coma y corchetes; se desazucaran a un núcleo con pares y lista vacía (Sección \ref{subsec:listas}).
\end{itemize}

\subsection{Semántica de los constructos (informal y decisiones justificadas)}

\subsubsection{Operadores variádicos y nuevos primitivos}\label{subsec:sem-arit}

\paragraph{Aridad y evaluación.} Los operadores \texttt{+ - * /} y los predicados \texttt{= < > <= >= !=} son
variádicos con aridad mínima 2. La evaluación de argumentos es por valor, de
izquierda a derecha.

\paragraph{Reducción de aritméticos.} Se adopta reducción por lista (\emph{fold-left}) con los siguientes esquemas,
todos sobre enteros:
\[
	\begin{aligned}
		(+\, a_1\,\dots\,a_n) & := (((a_1 + a_2) + a_3) + \dots + a_n)                     \\
		(*\, a_1\,\dots\,a_n) & := (((a_1 \times a_2) \times a_3) \times \dots \times a_n) \\
		(-\, a_1\,\dots\,a_n) & := (((a_1 - a_2) - a_3) - \dots - a_n)                     \\
		(/\, a_1\,\dots\,a_n) & := (((a_1 \div a_2) \div a_3) \div \dots \div a_n)
	\end{aligned}
\]
La división \(\div\) es entera por truncamiento hacia cero. Error si algún
divisor es cero.

\paragraph{Primitivos.}
\[
	\begin{aligned}
		\texttt{add1}(n)   & := n + 1, \qquad
		\texttt{sub1}(n) := n - 1,                                                \\
		\texttt{sqrt}(n)   & := \left\lfloor \sqrt{n}\right\rfloor \ \ (n \ge 0), \\
		\texttt{expt}(b,e) & := b^e \ \ (e \ge 0\ \text{entero}).
	\end{aligned}
\]
Errores: \texttt{sqrt} con argumento negativo; \texttt{expt} con exponente
negativo.

\subsubsection{Predicados variádicos sobre enteros}

\paragraph{Interpretación en cadena.} Para \texttt{<, >, <=, >=} se adopta la semántica de cadena:
\[
	(<\ a_1\ \dots\ a_n) \equiv (a_1<a_2) \wedge (a_2<a_3)\wedge \dots \wedge (a_{n-1}<a_n)
\]
y análogamente para \texttt{>}, \texttt{<=}, \texttt{>=}.
\paragraph{Igualdad y desigualdad.}
\[
	(=\ a_1\ \dots\ a_n) \equiv \bigwedge_{i=1}^{n-1}(a_i = a_{i+1}),\quad
	(!=\ a_1\ \dots\ a_n) \equiv \bigwedge_{1\le i<j\le n}(a_i \ne a_j).
\]
Estas operaciones solo aceptan enteros; mezclar tipos es error.

\subsubsection{Pares ordenados y proyecciones}\label{subsec:pares}

\paragraph{Formación y proyección.} La notación \texttt{(e\_1, e\_2)} construye el par \(\langle v_1, v_2\rangle\)
tras evaluar los componentes.
\[
	\texttt{(fst p)} \Rightarrow v_1,\qquad \texttt{(snd p)} \Rightarrow v_2,
\]
con error si \texttt{p} no es un par.

\subsubsection{Asignaciones locales: \texttt{let} y \texttt{let*}}

\paragraph{Ámbito.} El alcance es léxico.
\paragraph{\texttt{let} (paralelo).} \texttt{(let ((x e\_x) (y e\_y) \dots) body)} evalúa \texttt{e\_x}, \texttt{e\_y}, \dots en el ambiente exterior y liga simultáneamente. Dependencias entre ligaduras son ilegales (error).
\paragraph{\texttt{let*} (secuencial).} \texttt{(let* ((x e\_x) (y e\_y) \dots) body)} introduce cada ligadura sobre el ambiente extendido por las anteriores; permite dependencias válidas.

\subsubsection{Condicional booleano: \texttt{if} y \texttt{if0}}

\paragraph{\texttt{if}.} \texttt{(if e\_1 e\_2 e\_3)} evalúa \texttt{e\_1}; si es \texttt{\#t} evalúa \texttt{e\_2}, si es \texttt{\#f} evalúa \texttt{e\_3}. Solo \texttt{\#t} y \texttt{\#f} son booleanos.
\paragraph{\texttt{if0} como azúcar.} Se define como azúcar sobre \texttt{if}:
\[
	\texttt{(if0 e a b)} \equiv \texttt{(if (= e 0) a b)}.
\]

\subsubsection{Listas, azúcares de corchetes y operaciones básicas}\label{subsec:listas}

\paragraph{Homogeneidad.} Las listas son heterogéneas.
\paragraph{Azúcar de listas.} La notación \texttt{[e\_1, \dots, e\_n]} se traduce a pares anidados terminados
en la lista vacía \texttt{[]}:
\[
	[] \equiv \texttt{nil},\quad
	[e_1] \equiv (e_1, []),\quad
	[e_1, e_2, \dots, e_n] \equiv (e_1, [e_2, \dots, e_n]).
\]
\paragraph{Operaciones.}
\[
	\texttt{(head L)}:\ L=(h,t)\Rightarrow h,\ \ \texttt{(tail L)}:\ L=(h,t)\Rightarrow t,
\]
error si \texttt{L} es \texttt{[]}.

\subsubsection{Condicional por clausulado: \texttt{cond} con \texttt{else}}

\paragraph{Reglas.} \texttt{(cond [g\_1 e\_1] \dots [g\_k e\_k] [else e\_d])}. Se evalúan guardas en orden y se elige la primera verdadera. \texttt{else} debe ser la última; si falta y ninguna guarda es verdadera, es error.

\subsubsection{Funciones anónimas y aplicaciones}

\paragraph{\texttt{lambda}.} \texttt{(lambda (x\_1 \dots x\_n) Expr)} define una función con aridad fija \(n\ge 1\). Parámetros distintos (error si repetidos).
\paragraph{Aplicación.} \texttt{(f a\_1 \dots a\_n)} evalúa \texttt{f} y los argumentos por valor (izquierda a derecha) y aplica con aridad exacta.

\subsection{Desambiguaciones, errores y diagnósticos}

\begin{itemize}
	\item \textbf{Tipos}: Aritméticos y predicados solo sobre enteros; otros tipos dan error de tipo.
	\item \textbf{División por cero}: error en tiempo de ejecución.
	\item \textbf{Raíz cuadrada}: error si el argumento es negativo.
	\item \textbf{Comparaciones variádicas}: aridad $<2$ es error (la EBNF ya lo previene).
	\item \textbf{\texttt{let} vs \texttt{let*}}: reportar dependencias ilegales en \texttt{let}.
	\item \textbf{Pares/listas}: \texttt{head}/\texttt{tail} sobre \texttt{[]} es error.
	\item \textbf{else en \texttt{cond}}: solo permitido como última cláusula.
\end{itemize}

\subsection{Resumen de tokens reservados}

\begin{center}
	\small
	\texttt{( ) [ ] , + - * / = < > <= >= != lambda let let* if if0 cond else fst snd head tail add1 sub1 sqrt expt \#t \#f}
\end{center}

\subsection{Ejemplos ilustrativos}

\begin{verbatim}
(+ 1 2 3 4)              ; 10
(* 3 4 5)                ; 60
(/ 64 4 2)               ; 8
(= 4 4 4)                ; #t
(< 2 5 5)                ; #f   (cadena estricta)
(!= 1 2 3 1)             ; #f

(fst (1, #t))            ; 1
(snd (3, 5))             ; 5

(let ((x 3) (y (+ x 1))) (+ x y))   ; ERROR (let paralelo)
(let* ((x 3) (y (+ x 1))) (+ x y))  ; 7

(if #t 1 2)               ; 1
(if0 0 42 0)              ; 42  == (if (= 0 0) 42 0)

[1, 2, 3, 4]              ; azucar de lista
(head [1, 2, 3])          ; 1
(tail [3, 5, 6])          ; [5, 6]
[]                        ; lista vacia

((lambda (x y z) (+ x y z)) 1 2 3)  ; 6
\end{verbatim}

\subsection{Notas de implementación (guía para el analizador léxico y sintáctico)}

\paragraph{Lexer.}
\begin{enumerate}
	\item Aplicar \emph{máximo munch}; reconocer primero dobles símbolos (\texttt{<=, >=,
		      !=}).
	\item Tratar \texttt{\#| \dots |\#} con contador de anidación.
	\item Diferenciar un literal \texttt{-?\,[0-9]+} de una aplicación \texttt{(- \dots)}
	      por contexto: un signo adosado a dígitos sin espacios en un lugar donde se
	      espera \texttt{Atom} forma un \texttt{INT}; en otro caso, \texttt{-} es token
	      operador.
\end{enumerate}

\paragraph{Parser.}
\begin{itemize}
	\item Para variádicos, usar una producción que consuma \(\ge 2\) expresiones (como en
	      la EBNF).
	\item Azúcar: traducir \texttt{(e1, e2)} a un constructor \texttt{Pair(e1, e2)} del
	      AST; traducir \texttt{[e\_1,\dots,e\_n]} a anidamiento \texttt{Pair(e\_1,
		      Pair(e\_2, \dots Pair(e\_n, Nil)\dots))}.
	\item \texttt{cond}: validar que \texttt{else} sólo aparece (a lo sumo) en la última cláusula.
\end{itemize}

\subsection{Garantías de diseño y alternativas consideradas}

\begin{itemize}
	\item \textbf{Comparaciones variádicas}: se prefirió \emph{cadena} frente a reducción acumulativa para alinear con lenguajes de la familia Lisp/Scheme y mejorar legibilidad matemática.
	\item \textbf{Enteros puros}: mantener el dominio en enteros simplifica la especificación y evita introducir reglas de coerción; \texttt{sqrt} con piso es un compromiso razonable y explícito.
	\item \textbf{Listas heterogéneas}: coherente con el uso de pares como núcleo y con la tradición Lisp; permite listas mixtas sin penalización.
	\item \textbf{Orden de evaluación}: fijo y de izquierda a derecha para predecibilidad y facilidad de pruebas.
\end{itemize}